"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[6739],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=o.createContext({}),u=function(e){var t=o.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return o.createElement(i.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),m=a,k=p["".concat(i,".").concat(m)]||p[m]||d[m]||s;return n?o.createElement(k,r(r({ref:t},c),{},{components:n})):o.createElement(k,r({ref:t},c))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,r=new Array(s);r[0]=m;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l[p]="string"==typeof e?e:a,r[1]=l;for(var u=2;u<s;u++)r[u]=n[u];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},760:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>u});var o=n(7462),a=(n(7294),n(3905));const s={sidebar_position:8},r="Custom hooks",l={unversionedId:"Custom-Hooks",id:"Custom-Hooks",title:"Custom hooks",description:"El archivo hooks.ts contiene una serie de hooks personalizados que facilitan el manejo de funcionalidades comunes en la app. Estos hooks abarcan \xe1reas como el manejo de eventos de hover, la detecci\xf3n de la resoluci\xf3n de pantalla y el acceso al contexto de usuario, entre otros.",source:"@site/docs/Custom-Hooks.mdx",sourceDirName:".",slug:"/Custom-Hooks",permalink:"/documentacion-frontend-budget/docs/Custom-Hooks",draft:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Traducciones",permalink:"/documentacion-frontend-budget/docs/React-intl"},next:{title:"Entry Point - App.tsx",permalink:"/documentacion-frontend-budget/docs/Entry-point"}},i={},u=[{value:"Hooks de detecci\xf3n de resoluci\xf3n de pantalla",id:"hooks-de-detecci\xf3n-de-resoluci\xf3n-de-pantalla",level:2},{value:"Hook useToggle",id:"hook-usetoggle",level:2},{value:"Hook useUserContext",id:"hook-useusercontext",level:2}],c={toc:u},p="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"custom-hooks"},"Custom hooks"),(0,a.kt)("p",null,"El archivo ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"hooks.ts"))," contiene una serie de hooks personalizados que facilitan el manejo de funcionalidades comunes en la app. Estos hooks abarcan \xe1reas como el manejo de eventos de hover, la detecci\xf3n de la resoluci\xf3n de pantalla y el acceso al contexto de usuario, entre otros."),(0,a.kt)("h2",{id:"hooks-de-detecci\xf3n-de-resoluci\xf3n-de-pantalla"},"Hooks de detecci\xf3n de resoluci\xf3n de pantalla"),(0,a.kt)("p",null,"Los siguientes hooks: ",(0,a.kt)("strong",{parentName:"p"},"useIsMobile, useIsTablet, useIsDesktop y useScreenBrakpoints"),", se utilizan para detectar la resoluci\xf3n de pantalla y adaptar el comportamiento de la aplicaci\xf3n en base a la resoluci\xf3n detectada."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"useIsMobile:")," Retorna un valor booleano indicando si la resoluci\xf3n de pantalla es menor a un tama\xf1o especificado (en este caso, el breakpoint 'sm' del tema)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"useIsTablet:")," Retorna un valor booleano indicando si la resoluci\xf3n de pantalla se encuentra entre dos tama\xf1os especificados (en este caso, los breakpoints 'sm' y 'lg' del tema)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"useIsDesktop:")," Retorna un valor booleano indicando si la resoluci\xf3n de pantalla es mayor a un tama\xf1o especificado (en este caso, el breakpoint 'lg' del tema)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"useScreenBrakpoints:")," Retorna un objeto con propiedades booleanas que indican si la resoluci\xf3n de pantalla cumple con diferentes rangos (por ejemplo, si es mayor a 'lg', mayor a 'xl', menor a 'sm', o se encuentra entre 'sm' y 'lg').")),(0,a.kt)("p",null,"Estos hooks utilizan el hook useTheme de Material-UI para obtener el tema actual de la aplicaci\xf3n y luego utilizan el hook useMediaQuery para realizar las consultas de media y obtener los resultados de detecci\xf3n de resoluci\xf3n de pantalla."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/src/utils/hooks.ts"',title:'"/src/utils/hooks.ts"'},"export const useIsMobile = () => {\n    const theme = useTheme()\n    return useMediaQuery(theme.breakpoints.down('sm'), { noSsr: true })\n}\n\nexport const useIsTablet = () => {\n    const theme = useTheme()\n    return useMediaQuery(theme.breakpoints.between('sm', 'lg'), { noSsr: true })\n}\n\nexport const useIsDesktop = () => {\n    const theme = useTheme()\n    return useMediaQuery(theme.breakpoints.up('lg'), { noSsr: true })\n}\n\nexport const useScreenBrakpoints = () => {\n    const theme = useTheme()\n    const isDownSm = useMediaQuery(theme.breakpoints.down('sm'), { noSsr: true })\n    const isUpLg = useMediaQuery(theme.breakpoints.up('lg'), { noSsr: true })\n    const isBetweenSmLg = useMediaQuery(theme.breakpoints.between('sm', 'lg'), { noSsr: true })\n    const isUpXl = useMediaQuery(theme.breakpoints.up('xl'), { noSsr: true })\n    return { isUpLg, isUpXl, isDownSm, isBetweenSmLg }\n}\n\n")),(0,a.kt)("h2",{id:"hook-usetoggle"},"Hook useToggle"),(0,a.kt)("p",null,"El hook ",(0,a.kt)("strong",{parentName:"p"},"useToggle")," se utiliza para manejar un estado booleano y proporciona funciones para cambiar el estado entre true y false. Este hook es \xfatil cuando se necesita manejar el estado de un interruptor, como el caso de un bot\xf3n de alternancia."),(0,a.kt)("p",null,"El hook utiliza el estado interno state para realizar el seguimiento del estado actual y proporciona las siguientes funciones:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"toggle:")," Cambia el estado actual entre true y false."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"setFalse:")," Establece el estado en false."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"setTrue:")," Establece el estado en true.")),(0,a.kt)("p",null,"Estas funciones se pueden llamar desde cualquier componente que utilice el hook useToggle para actualizar el estado y realizar acciones basadas en el cambio de estado."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/src/utils/hooks.ts"',title:'"/src/utils/hooks.ts"'},"export const useToggle = (initialState = false) => {\n    // Initialize the state\n    const [state, setState] = useState(initialState)\n\n    // Define and memorize toggler function in case we pass down the component,\n    // This function change the boolean value to it's opposite value\n    const toggle = useCallback(() => setState((state) => !state), [])\n    const setFalse = () => setState(false)\n    const setTrue = () => setState(true)\n\n    return { state, toggle, setFalse, setTrue }\n}\n\n")),(0,a.kt)("h2",{id:"hook-useusercontext"},"Hook useUserContext"),(0,a.kt)("p",null,"El hook ",(0,a.kt)("strong",{parentName:"p"},"useUserContext")," se utiliza para acceder al contexto de usuario definido en el componente ",(0,a.kt)("strong",{parentName:"p"},"UserContext"),". Permite obtener el valor actual del contexto de usuario en cualquier componente hijo que lo utilice.\nEs importante tener en cuenta que el componente ",(0,a.kt)("strong",{parentName:"p"},"UserContext")," debe estar envolviendo a los componentes donde se utiliza el hook ",(0,a.kt)("strong",{parentName:"p"},"useUserContext")," para que este pueda acceder correctamente al contexto de usuario."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/src/utils/hooks.ts"',title:'"/src/utils/hooks.ts"'},"export const useUserContext = () => {\n    return useContext(UserContext)\n}\n\n")))}d.isMDXComponent=!0}}]);