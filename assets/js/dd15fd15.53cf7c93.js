"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[6522],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>g});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var i=a.createContext({}),p=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(i.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(t),m=o,g=u["".concat(i,".").concat(m)]||u[m]||d[m]||r;return t?a.createElement(g,s(s({ref:n},c),{},{components:t})):a.createElement(g,s({ref:n},c))}));function g(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,s=new Array(r);s[0]=m;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l[u]="string"==typeof e?e:o,s[1]=l;for(var p=2;p<r;p++)s[p]=t[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1784:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=t(7462),o=(t(7294),t(3905));const r={},s="FiltersBar",l={unversionedId:"Components/Screens/BudgetScreen/FiltersBar",id:"Components/Screens/BudgetScreen/FiltersBar",title:"FiltersBar",description:"El componente FiltersBar esta compuesto por sub-componentes los cuales sirven para implementar filtros que le van a permitir a usuario filtrar y visualizar informaci\xf3n de acuerdo con ciertos criterios.",source:"@site/docs/Components/Screens/BudgetScreen/FiltersBar.mdx",sourceDirName:"Components/Screens/BudgetScreen",slug:"/Components/Screens/BudgetScreen/FiltersBar",permalink:"/documentacion-frontend-budget/docs/Components/Screens/BudgetScreen/FiltersBar",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Components/Screens/BudgetScreen/FiltersBar.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"CountryDataTable",permalink:"/documentacion-frontend-budget/docs/Components/Screens/BudgetScreen/CountryDataTable"},next:{title:"LoadingScreen",permalink:"/documentacion-frontend-budget/docs/Components/Screens/BudgetScreen/LoadingScreen"}},i={},p=[{value:"Sub-componentes principales",id:"sub-componentes-principales",level:2},{value:"Definici\xf3n de types y props",id:"definici\xf3n-de-types-y-props",level:3},{value:"Filter",id:"filter",level:3},{value:"FilterMobile",id:"filtermobile",level:3},{value:"DesktopFilters",id:"desktopfilters",level:3},{value:"MobileFilters",id:"mobilefilters",level:3},{value:"FilterBreadcrumb",id:"filterbreadcrumb",level:3},{value:"Componente principal",id:"componente-principal",level:2}],c={toc:p},u="wrapper";function d(e){let{components:n,...t}=e;return(0,o.kt)(u,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"filtersbar"},"FiltersBar"),(0,o.kt)("p",null,"El componente ",(0,o.kt)("strong",{parentName:"p"},"FiltersBar")," esta compuesto por sub-componentes los cuales sirven para implementar filtros que le van a permitir a usuario filtrar y visualizar informaci\xf3n de acuerdo con ciertos criterios."),(0,o.kt)("h2",{id:"sub-componentes-principales"},"Sub-componentes principales"),(0,o.kt)("h3",{id:"definici\xf3n-de-types-y-props"},"Definici\xf3n de types y props"),(0,o.kt)("p",null,"En primera instancia se declaran los types y filtros seg\xfan los dispostivos (desktop o mobiles). Los ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," establecen una interfaz que define la estructura de un objeto que se utiliza para representar las propiedades (en este caso de un componente de filtro).\nEsto permite definir la estructura de las propiedades que se pasan a un componente de filtro y garantizar que se utilicen correctamente."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/components/screens/BudgetScreen/FiltersBar.tsx"',title:'"/components/screens/BudgetScreen/FiltersBar.tsx"'},"// type para el componente final que va a ser exportado (el cual incluye los 3 filtros)\ntype Props = {\n    onFilterChange: (filters: { period: string; propertyName: string; formOfSale: 'dorm' | 'room' | 'global'| 'apart' }) => void\n    applyFilters: () => void\n    actualFilters: { period: string; propertyName: string; formOfSale: 'dorm' | 'room' | 'global'| 'apart' }\n    properties?: Property[]\n    typologies?: Typology[]\n}\n\n// type utilizado para renderizar cada filtro individualmente\ntype FilterProps = {\n    label: string\n    options: string[] | { value: string; label: string }[]\n    onChange?: (option: string) => void\n    value: string | { value: string; label: string }\n} \n\n// type que define una estrutura espec\xedfica dentro de CustomFilterProps\ntype FilterOption = {\n    value: string\n    label: string\n}\n\n// type utilizado en el componente final junto al type Props (desktop)\ntype CustomFilterProps = {\n    datesOptions: FilterOption[]\n    formOfSaleOptions: FilterOption[]\n}\n\n// type utilizado en el componente final junto al type Props (mobile)\ntype CustomFilterPropsMobile = {\n    datesOptions: FilterOption[]\n    formOfSaleOptions: FilterOption[]\n    propertyNameOptions: FilterOption[]\n}\n\n")),(0,o.kt)("h3",{id:"filter"},"Filter"),(0,o.kt)("p",null,"El componente ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"Filter"))," acepta ciertas propiedades ",(0,o.kt)("strong",{parentName:"p"},"(FilterProps)"),", las desestructura y las utiliza para configurar y renderizar un componente ",(0,o.kt)("strong",{parentName:"p"},"Autocomplete")," de Material-UI."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"const { label, options, onChange, value, properties } = props"),":")," Filter desestructura las props pasadas al componente para acceder a sus valores individuales. "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"const realValue = typeof value === 'string' ? { value, label: value } : value"),":"),"  Aca se verifica si el tipo de value es una cadena (string). Si es una cadena, se crea un nuevo objeto con las propiedades value y label establecidas con los mismos valores. Si value no es una cadena, se asigna directamente a realValue. Esta l\xednea se utiliza para asegurarse de que realValue siempre tenga una estructura espec\xedfica, independientemente del tipo de value que se pase."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"const realOptions = options.map((option) => (typeof option === 'string' ? { value: option, label: option } : option))"),":")," En esta constante se utiliza el m\xe9todo map para recorrer el array options. Para cada elemento en options, se verifica si el tipo de option es una cadena (string). Si es as\xed, se crea un nuevo objeto con las propiedades value y label establecidas con los mismos valores. Si option no es una cadena, se asigna directamente a realOptions. Esto asegura que realOptions siempre tenga una estructura espec\xedfica, independientemente del tipo de elementos que haya en options.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/components/screens/BudgetScreen/FiltersBar.tsx"',title:'"/components/screens/BudgetScreen/FiltersBar.tsx"'},'const Filter: FC<FilterProps> = (props) => {\nconst { label, options, onChange, value, properties } = props\nconst realValue = typeof value === \'string\' ? { value, label: value } : value\nconst realOptions = options.map((option) => (typeof option === \'string\' ? { value: option, label: option } : option))\n\nreturn (\n    <Autocomplete\n        disablePortal\n        value={realValue}\n        onChange={(event, select) => select && onChange && onChange(select.value)}\n        options={realOptions}\n        inputValue={realValue.label}\n        renderInput={(params) => <TextField variant="filled" {...params} label={label} />}\n        size="small"\n        className="top-bar-filter"\n    />\n    )\n}\n\n')),(0,o.kt)("h3",{id:"filtermobile"},"FilterMobile"),(0,o.kt)("p",null,"El componente ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"FilterMobile"))," que es una variante del componente ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"Filter"))," original, adaptado para su uso en una vista m\xf3vil. Introduce propiedades adicionales y estados locales para controlar el estado de apertura/cierre del componente en una vista."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"const { label, options, onChange, isOpen, onOpen, onClose } = props"),":")," FilterMobile desestructura las props pasadas al componente para acceder a sus valores individuales y adiciona otras como isOpen, onOpen y onClose.. "),(0,o.kt)("li",{parentName:"ul"},"Se declara un estado local ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"activeState"))," como un objeto que mapea claves de tipo string a valores booleanos, inicializado seg\xfan las opciones proporcionadas."),(0,o.kt)("li",{parentName:"ul"},"Se declara un estado local ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"lastSelected"))," para almacenar la \xfaltima opci\xf3n seleccionada."),(0,o.kt)("li",{parentName:"ul"},"Se declara un estado local ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"currentLabel"))," para almacenar la etiqueta actual del componente."),(0,o.kt)("li",{parentName:"ul"},"Se define la funci\xf3n ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"handleListItemActive"))," que se ejecuta cuando se hace clic en un elemento de la lista. Actualiza los estados ",(0,o.kt)("strong",{parentName:"li"},"activeState"),", ",(0,o.kt)("strong",{parentName:"li"},"lastSelected")," y ",(0,o.kt)("strong",{parentName:"li"},"currentLabel"),", y llama a ",(0,o.kt)("strong",{parentName:"li"},"onClose")," para cerrar el componente."),(0,o.kt)("li",{parentName:"ul"},"Los elementos de la lista se generan a partir del array ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"options")),", y se aplican clases y manejadores de eventos seg\xfan el estado ",(0,o.kt)("strong",{parentName:"li"},"activeState")," y las funciones ",(0,o.kt)("strong",{parentName:"li"},"handleListItemActive")," y ",(0,o.kt)("strong",{parentName:"li"},"onChange"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/components/screens/BudgetScreen/FiltersBar.tsx"',title:'"/components/screens/BudgetScreen/FiltersBar.tsx"'},"const FilterMobile: FC<\n    FilterProps & {\n        isOpen?: boolean\n        onOpen: () => void\n        onClose: () => void\n    }\n> = (props) => {\n    const { label, options, onChange, isOpen, onOpen, onClose } = props\n\n    const [activeState, setActiveStates] = useState<{ [key: string]: boolean }>(\n        options.map((option) => (typeof option === 'string' ? option : option.value))\n        options.reduce((acc, option) => ({ ...acc, [option]: false,}), {}, )\n    )\n    const [lastSelected, setLastSelected] = useState('')\n    const [currentLabel, setCurrentLabel] = useState(label)\n\n    const handleListItemActive = (option: string) => {\n        setActiveStates((prevActiveStates) => {\n            const newActiveStates = { ...prevActiveStates }\n            if (lastSelected) {\n                newActiveStates[lastSelected] = false\n            }\n            newActiveStates[option] = !newActiveStates[option]\n            setLastSelected(option)\n\n            const selectedOption = (() => {\n                for (const o of options) {\n                    if (typeof o === 'string') {\n                        continue\n                    }\n\n                    if (o.value === option) {\n                        return o\n                    }\n                }\n\n                return undefined\n            })()\n\n            const newLabel = selectedOption ? selectedOption.label : label\n            setCurrentLabel(newLabel)\n            onClose()\n            return newActiveStates\n        })\n    }\n\n    return (\n        <Accordion expanded={!!isOpen} elevation={0} className=\"filter-accordion\">\n            <AccordionSummary onClick={onOpen} expandIcon={<ExpandLessIcon />} aria-controls={`${label}-content`} id={`${label}-header`}>\n                {currentLabel}\n            </AccordionSummary>\n            <AccordionDetails>\n                <List>\n                    {options.map((option) => {\n                        const isString = typeof option === 'string'\n                        const label = isString ? option : option.label\n                        const value = isString ? option : option.value\n                        return (\n                            <ListItemButton\n                                className={activeState[value] ? 'activar' : ''}\n                                onClickCapture={() => handleListItemActive(value)}\n                                onClick={() => onChange && onChange(value)}\n                                key={value}\n                            >\n                                {label}\n                            </ListItemButton>\n                        )\n                    })}\n                </List>\n            </AccordionDetails>\n        </Accordion>\n    )\n}\n\n")),(0,o.kt)("h3",{id:"desktopfilters"},"DesktopFilters"),(0,o.kt)("p",null,"El componente ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"DesktopFilters"))," renderiza una barra de filtros para la versi\xf3n de escritorio de Budget. Permite seleccionar ",(0,o.kt)("strong",{parentName:"p"},"Propiedades (Properties)"),", ",(0,o.kt)("strong",{parentName:"p"},"Periodos (Period)")," y ",(0,o.kt)("strong",{parentName:"p"},"Tipolog\xedas (Typologies)"),", y aplicar los filtros para ver los datos solicitados reflejados en los gr\xe1ficos ",(0,o.kt)("strong",{parentName:"p"},"(BudgetCards)"),"."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Se declara un estado local ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"formOfSaleOptions"))," utilizando el hook useState, inicializado con el valor de ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"props.formOfSaleOptions")),"."),(0,o.kt)("li",{parentName:"ul"},"Se define la funci\xf3n ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"onChangeProperty"))," que se ejecuta cuando se cambia la propiedad seleccionada. Dentro de esta funci\xf3n, se llama a ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"onFilterChange"))," para actualizar el filtro actual con la nueva propiedad seleccionada. Luego, se actualiza ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"formOfSaleOptions"))," filtrando las tipolog\xedas correspondientes a la propiedad seleccionada y transformando sus datos en el formato requerido."),(0,o.kt)("li",{parentName:"ul"},"Se define la funci\xf3n ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"onChangePeriod"))," que se ejecuta cuando se cambia el per\xedodo seleccionado. Dentro de esta funci\xf3n, se llama a ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"onFilterChange"))," para actualizar el filtro actual con el nuevo per\xedodo seleccionado."),(0,o.kt)("li",{parentName:"ul"},"Se define la funci\xf3n ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"onChangeformOfSale"))," que se ejecuta cuando se cambia la forma de venta seleccionada. Dentro de esta funci\xf3n, se llama a ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"onFilterChange"))," para actualizar el filtro actual con la nueva forma de venta seleccionada."),(0,o.kt)("li",{parentName:"ul"},"Se obtiene el valor del form of sale actual y el valor de la fecha actual utilizando los valores de ",(0,o.kt)("strong",{parentName:"li"},"formOfSaleOptions, actualFilters y datesOptions"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/components/screens/BudgetScreen/CountryDataTable.tsx"',title:'"/components/screens/BudgetScreen/CountryDataTable.tsx"'},"const DesktopFilters: FC<Props & CustomFilterProps> = (props) => {\n    const { onFilterChange, datesOptions, properties, actualFilters, applyFilters } = props\n    const [formOfSaleOptions, setFormOfSaleOptions] = useState(props.formOfSaleOptions)\n\n    const onChangeProperty = (propertyName: string) => {\n        onFilterChange({\n            ...actualFilters,\n            propertyName,   \n        })\n        \n        setFormOfSaleOptions(properties?.find(p => p.name === propertyName)?.typologies.map(t => {\n            return {\n                value: t.alias,\n                label: t.visualName === 'Apartamentos' ? formatMessage(BudgetMessages.apart) :\n                        t.visualName === 'Dormitorios' ? formatMessage(BudgetMessages.dorm) :\n                        t.visualName === 'Privadas' ? formatMessage(BudgetMessages.room) : t.visualName,\n            }\n        }) || [])\n    }\n\n    const onChangePeriod = (period: string) => {\n        onFilterChange({\n            ...actualFilters,\n            period,\n        })\n    }\n\n    const onChangeformOfSale = (formOfSale: string) => {\n        onFilterChange({\n            ...actualFilters,\n            formOfSale: formOfSale as 'dorm' | 'room' | 'global' | 'apart'            \n        })\n\n    }\n\n    const formOfSaleValue = formOfSaleOptions?.find((option) => option.value === actualFilters.formOfSale) || { label: '', value: '' }\n    const dateValue = datesOptions.find((option) => option.value === actualFilters.period) || { label: '', value: '' }\n    const { formatMessage } = useIntl()\n    return (\n        <div className=\"filters-bar desktop\">\n            <Filter\n                value={actualFilters.propertyName}\n                onChange={onChangeProperty}\n                options={properties?.map(p => p.name) || []}\n                label={formatMessage(BudgetMessages.property)}\n            />\n            <Filter \n                value={dateValue} \n                options={datesOptions} \n                label={formatMessage(BudgetMessages.currentMonth)} \n                onChange={onChangePeriod} \n            />\n            <Filter\n                value={formOfSaleValue} \n                onChange={onChangeformOfSale}\n                options={formOfSaleOptions || []} \n                label={formatMessage(BudgetMessages.allTypologies)} \n            />\n            <Button onClick={applyFilters} className=\"button-filter\" disableElevation variant=\"contained\">\n                {formatMessage(BudgetMessages.apply)}\n            </Button>\n        </div>\n    )\n}\n\n")),(0,o.kt)("h3",{id:"mobilefilters"},"MobileFilters"),(0,o.kt)("p",null,"El componente ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"MobileFilters"))," renderiza una barra de filtros para la versi\xf3n m\xf3vil de Budget. Permite seleccionar ",(0,o.kt)("strong",{parentName:"p"},"Propiedades (Properties)"),", ",(0,o.kt)("strong",{parentName:"p"},"Periodos (Period)")," y ",(0,o.kt)("strong",{parentName:"p"},"Tipolog\xedas (Typologies)"),", y aplicar los filtros para ver los datos solicitados reflejados en los gr\xe1ficos ",(0,o.kt)("strong",{parentName:"p"},"(BudgetCards)"),"."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Define las mismas funciones ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"DesktopFilters")),"  (",(0,o.kt)("inlineCode",{parentName:"li"},"onChangeProperty"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"onChangePeriod")," y ",(0,o.kt)("inlineCode",{parentName:"li"},"onChangeformOfSale"),") que se ejecutan cuando seg\xfan la selecci\xf3n del usuario. "),(0,o.kt)("li",{parentName:"ul"},"Utiliza los hooks ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"useToggle"))," y ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"useState"))," para controlar el estado de apertura/cierre del men\xfa desplegable y qu\xe9 pesta\xf1a del men\xfa est\xe1 abierta."),(0,o.kt)("li",{parentName:"ul"},"Obtiene los valores seleccionados de los filtros actuales y los asigna a variables ",(0,o.kt)("strong",{parentName:"li"},"(formOfSaleValue, dateValue, propertyNameValue)")," para mostrar las opciones seleccionadas."),(0,o.kt)("li",{parentName:"ul"},"Define funciones ",(0,o.kt)("strong",{parentName:"li"},"(handlePropertyChange, handleDateChange, handleFormOfSaleChange)")," que se llaman cuando se selecciona una opci\xf3n en los filtros correspondientes. Estas funciones actualizan los filtros actuales y las etiquetas de los filtros seleccionados.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/components/screens/BudgetScreen/CountryDataTable.tsx"',title:'"/components/screens/BudgetScreen/CountryDataTable.tsx"'},"const MobileFilters: FC<Props & CustomFilterPropsMobile> = (props) => {\nconst { onFilterChange, datesOptions, properties, actualFilters, applyFilters, propertyNameOptions } = props\n    const [formOfSaleOptions, setFormOfSaleOptions] = useState(props.formOfSaleOptions)\n    \n    const onChangeProperty = (propertyName: string) => {\n        onFilterChange({\n            ...actualFilters,\n            propertyName,\n        })\n\n        setFormOfSaleOptions(properties?.find(p => p.name === propertyName)?.typologies.map(t => {\n            return {\n                value: t.alias,\n                label: t.visualName === 'Apartamentos' ? formatMessage(BudgetMessages.apart) :\n                     t.visualName === 'Dormitorios' ? formatMessage(BudgetMessages.dorm) : \n                     t.visualName === 'Privadas' ? formatMessage(BudgetMessages.room) : t.visualName,\n            }\n        }) || [])\n    }\n\n    const onChangePeriod = (period: string) => {\n        onFilterChange({\n            ...actualFilters,\n            period,\n        })\n    }\n\n    const onChangeformOfSale = (formOfSale: string) => {\n        onFilterChange({\n            ...actualFilters,\n            formOfSale: formOfSale as 'dorm' | 'room' | 'global' | 'apart',\n        })\n    }\n\n    const { state: isOpenMenu, toggle: toggleMenu, setFalse: closeMenu } = useToggle(false)\n    const [accordionTabOpened, setAccordionTabOpened] = useState<string>('')\n    const onFilterToggle = (tab: string) => {\n        setAccordionTabOpened((prevState) => (prevState === tab ? '' : tab))\n    }\n    const formOfSaleValue = formOfSaleOptions.find((option) => option.value === actualFilters.formOfSale) || { label: '', value: '' }\n    const dateValue = datesOptions.find((option) => option.value === actualFilters.period) || { label: '', value: '' }\n    const propertyNameValue = propertyNameOptions.find((option) => option.value === actualFilters.propertyName) || { label: '', value: '' }\n    const { formatMessage } = useIntl()\n\n    const [propertyLabel, setPropertyLabel] = useState<string>('')\n    const [dateLabel, setDateLabel] = useState<string>('')\n    const [formOfSaleLabel, setFormOfSaleLabel] = useState<string>('')\n\n    const handlePropertyChange = (option: string) => {\n        onChangeProperty(option)\n        setPropertyLabel(option)\n    }\n\n    const handleDateChange = (option: string) => {\n        onChangePeriod(option)\n        setDateLabel(option)\n    }\n\n    const handleFormOfSaleChange = (option: string) => {\n        onChangeformOfSale(option)\n        setFormOfSaleLabel(option)\n    }\n\n\n    const applyFiltersAndToggleMenu = () => {\n        applyFilters();\n        closeMenu();\n    };\n\n    return (\n        <div className=\"filters-bar mobile\">\n            <IconButton onClick={toggleMenu} className=\"mobile-menu-button\">\n                {isOpenMenu ? <Icon>close</Icon> : <Icon>menu</Icon>}\n            </IconButton>\n            {\n                <Drawer className=\"budget-mobile-filters-drawer\" anchor={'left'} open={isOpenMenu} onClose={closeMenu}>\n                    <div className=\"subtitle\">\n                        <Icon>tune</Icon>\n                        <label>Filtros</label>\n                        <Button onClick={applyFiltersAndToggleMenu} className=\"button-filter-mobile\" disableElevation variant=\"contained\">\n                            {formatMessage(BudgetMessages.apply)}\n                        </Button>\n                    </div>\n\n                    <FilterMobile\n                        isOpen={accordionTabOpened === 'Property'}\n                        onOpen={() => onFilterToggle('Property')}\n                        options={propertyNameOptions}\n                        value={propertyNameValue}\n                        label={formatMessage(BudgetMessages.property)}\n                        onChange={handlePropertyChange}\n                        onClose={() => setAccordionTabOpened('')}\n                    />\n                    <FilterMobile\n                        value={dateValue}\n                        isOpen={accordionTabOpened === 'Current month'}\n                        onOpen={() => onFilterToggle('Current month')}\n                        options={datesOptions}\n                        label={formatMessage(BudgetMessages.currentMonth)}\n                        onChange={handleDateChange}\n                        onClose={() => setAccordionTabOpened('')}\n                    />\n                    <FilterMobile\n                        value={formOfSaleValue}\n                        isOpen={accordionTabOpened === 'All typologies'}\n                        onOpen={() => onFilterToggle('All typologies')}\n                        options={formOfSaleOptions}\n                        label={formatMessage(BudgetMessages.allTypologies)}\n                        onChange={handleFormOfSaleChange}\n                        onClose={() => setAccordionTabOpened('')}\n                    />\n                </Drawer>\n            }\n        </div>\n    )\n}\n\n")),(0,o.kt)("h3",{id:"filterbreadcrumb"},"FilterBreadcrumb"),(0,o.kt)("p",null,"El componente muestra los breadcrumbs de los filtros seleccionados para la versi\xf3n m\xf3vil."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/components/screens/BudgetScreen/CountryDataTable.tsx"',title:'"/components/screens/BudgetScreen/CountryDataTable.tsx"'},'\ntype BreadCrumbsProps = {\n    onFilterChange: (filters: { period: string; propertyName: string; formOfSale: \'dorm\' | \'room\' | \'global\' | \'apart\' }) => void\n    actualFilters: { period: string; propertyName: string; formOfSale: \'dorm\' | \'room\' | \'global\' | \'apart\' }\n    properties?: Property[]\n}\n\nexport const FilterBreadcrumb: FC<BreadCrumbsProps> = (props) => {\n    const {actualFilters, properties} = props\n\n    const currentProperty = properties?.find((property) => property.name === actualFilters.propertyName);\n    const currentTypology = currentProperty?.typologies.find((typology) => typology.alias === actualFilters.formOfSale);\n\n    return (\n      <Breadcrumbs separator={<NavigateNextIcon fontSize="small" />} aria-label="breadcrumb">\n        <Link href="#" color="inherit" underline="none">{actualFilters.propertyName}</Link>\n        <Link href="#" color="inherit" underline="none">{actualFilters.period}</Link>\n        <Link href="#" color="inherit" underline="none">{currentTypology?.visualName}</Link>\n      </Breadcrumbs>\n    );\n}\n\n')),(0,o.kt)("h2",{id:"componente-principal"},"Componente principal"),(0,o.kt)("p",null,"El componente ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"FiltersBar"))," que es responsable de mostrar la barra de filtros en Budget. renderiza el componente ",(0,o.kt)("strong",{parentName:"p"},"(MobileFilters o DesktopFilters)")," dependiendo de si la aplicaci\xf3n se est\xe1 ejecutando en un dispositivo m\xf3vil o de escritorio."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Utiliza el hook ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"useIsMobile"))," para determinar si la aplicaci\xf3n se est\xe1 ejecutando en un dispositivo m\xf3vil."),(0,o.kt)("li",{parentName:"ul"},"La funci\xf3n ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"getXPreviousMonthsFromDateOption"))," recibe un n\xfamero de mes y un a\xf1o y devuelve un objeto con una opci\xf3n de fecha en formato yyyy-MM y una etiqueta en formato LLLL yyyy. Esta funci\xf3n se utiliza para generar las opciones de fechas disponibles."),(0,o.kt)("li",{parentName:"ul"},"La variable ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"currentYear"))," almacena el a\xf1o actual."),(0,o.kt)("li",{parentName:"ul"},"Se genera una lista de opciones de fechas ",(0,o.kt)("strong",{parentName:"li"},"(datesOptions)")," para los 12 meses del a\xf1o utilizando la funci\xf3n ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"getXPreviousMonthsFromDateOption")),". Solo se incluyen las opciones que contienen el a\xf1o actual en la etiqueta."),(0,o.kt)("li",{parentName:"ul"},"La variable ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"formOfSaleOptions"))," se crea a partir de las propiedades disponibles. Si existen propiedades, se mapean las tipolog\xedas de la primera propiedad para crear un objeto con el valor de la tipolog\xeda (t.alias), la etiqueta visual de la tipolog\xeda (t.visualName) y el idioma del usuario (getDateLocale(userLocale))."),(0,o.kt)("li",{parentName:"ul"},"La variable ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"propertyNameOptions"))," se crea utilizando el hook useMemo para memorizar su valor. Si no existen propiedades, se devuelve una lista vac\xeda. De lo contrario, se mapean las propiedades para crear un objeto con el valor y la etiqueta del nombre de la propiedad."),(0,o.kt)("li",{parentName:"ul"},"El componente renderiza los componentes ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"MobileFilters o DesktopFilters"))," seg\xfan el valor de isMobile. Pasa las props recibidas al componente correspondiente, junto con las opciones de fechas (datesOptions), opciones de forma de venta (formOfSaleOptions), y opciones de nombres de propiedades (propertyNameOptions).")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/components/screens/BudgetScreen/CountryDataTable.tsx"',title:'"/components/screens/BudgetScreen/CountryDataTable.tsx"'},"export const FiltersBar: FC<Props> = (props) => {\n    const { properties } = props\n    const isMobile = useIsMobile()\n    const { locale: userLocale } = useUserContext()\n\n    const getXPreviousMonthsFromDateOption = (month: number, year: number) => {\n        const date = new Date()\n        date.setDate(1)\n        date.setMonth(month)\n        date.setFullYear(year)\n        const locale = getDateLocale(userLocale)\n        return { value: format(date, 'yyyy-MM', { locale }), label: upperFirst(format(date, 'LLLL yyyy', { locale })) }\n    }\n    \n    const currentYear = new Date().getFullYear()\n    \n    const datesOptions = []\n    for (let i = 0; i < 12; i++) {\n        const option = getXPreviousMonthsFromDateOption(i, currentYear)\n        if (option.label.includes(currentYear.toString())) {\n            datesOptions.push(option)\n        }\n    }\n\n    const { formatMessage } = useIntl()\n    const formOfSaleOptions = properties ? properties[0].typologies\n        .map(t => ({\n            value: t.alias,\n            label: t.visualName,\n            locale: getDateLocale(userLocale)\n        })) : []\n\n    const propertyNameOptions = useMemo(() => {\n        if (!properties) {\n            return []\n        }\n\n        return properties.map((property) => ({\n            value: property.name,\n            label: property.name,\n        }))\n    }, [properties])\n   \n\n    return isMobile ? (\n        <MobileFilters {...props} datesOptions={datesOptions} formOfSaleOptions={formOfSaleOptions} propertyNameOptions={propertyNameOptions} />\n    ) : (\n        <DesktopFilters {...props} datesOptions={datesOptions} formOfSaleOptions={formOfSaleOptions} />\n    )\n}\n\n")))}d.isMDXComponent=!0}}]);